namespace FluidTrade.MiddleTierGenerator.TargetClass
{

    using System.CodeDom;
    using System.Collections.Generic;
    using FluidTrade.Core;

	/// <summary>
	/// Creates the CodeDOM of a method to destroy a record using transacted logic.
	/// </summary>
	/// <copyright>Copyright © 2006-2008 - Fluid Trade, Inc.  All Rights Reserved.</copyright>
	public class DestroyMethod : CodeMemberMethod
	{

		/// <summary>
		/// Creates the CodeDOM for a method to delete a record from a table using transacted logic.
		/// </summary>
		/// <param name="tableSchema">A description of the table.</param>
		public DestroyMethod(TableSchema tableSchema)
		{

			// Create a matrix of parameters for this operation.
			DestroyParameterMatrix destroyParameterMatrix = new DestroyParameterMatrix(tableSchema);

			// This is the key used to identify the record to be deleted.
			CodeArgumentReferenceExpression primaryKeyExpression = null;
			foreach (KeyValuePair<string, ExternalParameterItem> externalParamterPair in destroyParameterMatrix.ExternalParameterItems)
				if (externalParamterPair.Value is UniqueConstraintParameterItem)
					primaryKeyExpression = new CodeArgumentReferenceExpression(externalParamterPair.Value.Name);

			// These are the names of common varibles generated by this CodeDOM.
			CodeTypeReference rowType = new CodeTypeReference(string.Format("{0}Row", tableSchema.Name));
			CodeVariableReferenceExpression rowVariableExpression = new CodeRandomVariableReferenceExpression();

			//        /// <summary>
			//        /// Deletes a Employee record.
			//        /// </summary>
			//        /// <param name="employeeId">The value for the EmployeeId column.</param>
			//        /// <param name="rowVersion">The value for the RowVersion column.</param>
			//        /// <param name="rowVersion">Used for Optimistic Concurrency Checking.</param>
			//        [global::System.ServiceModel.OperationBehaviorAttribute(TransactionScopeRequired=true)]
			//        [FluidTrade.Core.ClaimsPrincipalPermission(System.Security.Permissions.SecurityAction.Demand, ClaimType=FluidTrade.Core.ClaimTypes.Destroy, Resource=FluidTrade.Core.Resources.Application)]
			//        public void DestroyEmployee(int employeeId, long rowVersion) {
			this.Comments.Add(new CodeCommentStatement("<summary>", true));
			this.Comments.Add(new CodeCommentStatement(string.Format("Deletes a {0} record.", tableSchema.Name), true));
			this.Comments.Add(new CodeCommentStatement("</summary>", true));
			foreach (KeyValuePair<string, ExternalParameterItem> parameterPair in destroyParameterMatrix.ExternalParameterItems)
				this.Comments.Add(new CodeCommentStatement(string.Format("<param name=\"{0}\">{1}</param>", parameterPair.Value.Name, parameterPair.Value.Description), true));
			this.CustomAttributes.Add(new CodeAttributeDeclaration(new CodeGlobalTypeReference(typeof(System.ServiceModel.OperationBehaviorAttribute)), new CodeAttributeArgument("TransactionScopeRequired", new CodePrimitiveExpression(true))));
			//AR FB 408 - Remove Claims requirement
			//this.CustomAttributes.Add(new CodeAttributeDeclaration(new CodeGlobalTypeReference(typeof(ClaimsPrincipalPermission)), new CodeAttributeArgument(new CodePropertyReferenceExpression(new CodeGlobalTypeReferenceExpression(typeof(System.Security.Permissions.SecurityAction)), "Demand")),
			//    new CodeAttributeArgument("ClaimType", new CodePropertyReferenceExpression(new CodeGlobalTypeReferenceExpression(typeof(ClaimTypes)), "Destroy")),
			//    new CodeAttributeArgument("Resource", new CodePropertyReferenceExpression(new CodeGlobalTypeReferenceExpression(typeof(Resources)), "Application"))));
			this.Attributes = MemberAttributes.Public | MemberAttributes.Final;
			this.Name = string.Format("Destroy{0}", tableSchema.Name);
			foreach (KeyValuePair<string, ExternalParameterItem> parameterPair in destroyParameterMatrix.ExternalParameterItems)
				this.Parameters.Add(parameterPair.Value.CodeParameterDeclarationExpression);

			// This method can't do much without a primary key.
			if (tableSchema.PrimaryKey == null)
				return;

			//            // This provides a context for the middle tier transactions.
			//            global::FluidTrade.Core.MiddleTierContext middleTierTransaction = global::FluidTrade.Core.MiddleTierContext.Current;
			CodeVariableReferenceExpression transactionExpression = new CodeRandomVariableReferenceExpression();
			this.Statements.Add(new CodeCreateMiddleTierContextStatement(tableSchema.DataModel, transactionExpression));

			//            // This record and any children in cascading relationships will be destroyed.
			//            FluidTrade.UnitTest.Server.DataModel.EmployeeRow employeeRow = FluidTrade.UnitTest.Server.DataModel.Employee.FindByEmployeeId(new object[] {
			//                        employeeId});
			//            if ((employeeRow == null)) {
			//                throw new global::System.ServiceModel.FaultException<RecordNotFoundFault>(new global::FluidTrade.Core.RecordNotFoundFault("Attempt to access a Employee record ({0}) that doesn\'t exist", employeeId));
			//            }
			this.Statements.Add(new CodeVariableDeclarationStatement(rowType, rowVariableExpression.VariableName, new CodeFindByIndexExpression(tableSchema, primaryKeyExpression)));
			this.Statements.Add(new CodeCheckRecordExistsStatement(tableSchema, rowVariableExpression, primaryKeyExpression));
			this.Statements.Add(new CodeAcquireRecordWriterLockExpression(transactionExpression, rowVariableExpression, tableSchema));
			this.Statements.Add(new CodeAddLockToTransactionExpression(transactionExpression, rowVariableExpression));

			//            // This makes sure the record wasn't deleted between the time it was found and the time it was locked.
			//            if ((employeeRow.RowState == System.Data.DataRowState.Detached)) {
			//                throw new global::System.ServiceModel.FaultException<RecordNotFoundFault>(new global::FluidTrade.Core.RecordNotFoundFault("Attempt to access a Employee record ({0}) that doesn\'t exist", employeeId));
			//            }
			this.Statements.Add(new CodeCheckRecordDetachedStatement(tableSchema, rowVariableExpression, primaryKeyExpression));

			//            // The Optimistic Concurrency check allows only one client to destroy a record at a time.
			//            if ((employeeRow.RowVersion != rowVersion)) {
			//                throw;
			//            }
			this.Statements.Add(new CodeCheckConcurrencyStatement(tableSchema, rowVariableExpression, primaryKeyExpression));

			//            // Delete each of the child Engineer records in a cascade.
			//            DataModel.EngineerRow[] employeeEngineerRowsByFK_Employee_Engineer = employeeRow.GetEngineerRows();
			//            for (int engineerIndex = 0; (engineerIndex < employeeEngineerRowsByFK_Employee_Engineer.Length); engineerIndex = (engineerIndex + 1)) {
			//                // Get the next Engineer row in the list of children and lock it for the duration of the transaction.
			//                DataModel.EngineerRow engineerRow = employeeEngineerRowsByFK_Employee_Engineer[engineerIndex];
			//                engineerRow.AcquireWriterLock(middleTierTransaction.AdoResourceManager.Guid, FluidTrade.UnitTest.Server.DataModel.lockTimeout);
			//                middleTierTransaction.AdoResourceManager.AddLock(engineerRow);
			//                // This makes sure the record wasn't deleted between the time it was found and the time it was locked.
			//                if ((engineerRow.RowState != System.Data.DataRowState.Detached)) {
			//                    this.DestroyEngineer(engineerRow.EngineerId, engineerRow.RowVersion);
			//                }
			//            }
			//            // Delete each of the child Manager records in a cascade.
			//            DataModel.ManagerRow[] employeeManagerRowsByFK_Employee_Manager = employeeRow.GetManagerRows();
			//            for (int managerIndex = 0; (managerIndex < employeeManagerRowsByFK_Employee_Manager.Length); managerIndex = (managerIndex + 1)) {
			//                // Get the next Manager row in the list of children and lock it for the duration of the transaction.
			//                DataModel.ManagerRow managerRow = employeeManagerRowsByFK_Employee_Manager[managerIndex];
			//                managerRow.AcquireWriterLock(middleTierTransaction.AdoResourceManager.Guid, FluidTrade.UnitTest.Server.DataModel.lockTimeout);
			//                middleTierTransaction.AdoResourceManager.AddLock(managerRow);
			//                // This makes sure the record wasn't deleted between the time it was found and the time it was locked.
			//                if ((managerRow.RowState != System.Data.DataRowState.Detached)) {
			//                    this.DestroyManager(managerRow.ManagerId, managerRow.RowVersion);
			//                }
			//            }
			//            // Delete each of the child ProjectMember records in a cascade.
			//            DataModel.ProjectMemberRow[] employeeProjectMemberRowsByFK_Employee_ProjectMember = employeeRow.GetProjectMemberRows();
			//            for (int projectMemberIndex = 0; (projectMemberIndex < employeeProjectMemberRowsByFK_Employee_ProjectMember.Length); projectMemberIndex = (projectMemberIndex + 1)) {
			//                // Get the next ProjectMember row in the list of children and lock it for the duration of the transaction.
			//                DataModel.ProjectMemberRow projectMemberRow = employeeProjectMemberRowsByFK_Employee_ProjectMember[projectMemberIndex];
			//                projectMemberRow.AcquireWriterLock(middleTierTransaction.AdoResourceManager.Guid, FluidTrade.UnitTest.Server.DataModel.lockTimeout);
			//                middleTierTransaction.AdoResourceManager.AddLock(projectMemberRow);
			//                // This makes sure the record wasn't deleted between the time it was found and the time it was locked.
			//                if ((projectMemberRow.RowState != System.Data.DataRowState.Detached)) {
			//                    this.DestroyProjectMember(projectMemberRow.EmployeeId, projectMemberRow.ProjectId, projectMemberRow.RowVersion);
			//                }
			//            }
			foreach (KeyValuePair<string, RelationSchema> relationPair in tableSchema.ChildRelations)
				if (relationPair.Value.ChildKeyConstraint.DeleteRule == ForeignKeyConstraintSchema.CascadeRules.Cascade)
				{

					// The child records in this table will be destroyed.
					TableSchema childTableSchema = relationPair.Value.ChildTable;

					// This collects the variables and types needed to build the statements to delete the child records.
					CodeVariableReferenceExpression iteratorVariableExpression = new CodeRandomVariableReferenceExpression();
					CodeTypeReference rowArrayType = new CodeTypeReference(string.Format("{0}Row[]", childTableSchema.Name));
					CodeVariableReferenceExpression rowArrayVariableExpression = new CodeRandomVariableReferenceExpression();
					CodeTypeReference childRowType = new CodeTypeReference(string.Format("{0}Row", childTableSchema.Name));
					CodeVariableReferenceExpression childRowVariableExpression = new CodeRandomVariableReferenceExpression();
					CodeMethodReferenceExpression getMethodExpression = relationPair.Value.IsDistinctPathToChild ?
						new CodeMethodReferenceExpression(rowVariableExpression, string.Format("Get{0}Rows", childTableSchema.Name)) :
						new CodeMethodReferenceExpression(rowVariableExpression, string.Format("Get{0}RowsBy{1}", childTableSchema.Name, relationPair.Value.Name));

					//            // Delete each of the child Engineer records in a cascade.
					//            DataModel.EngineerRow[] employeeEngineerRowsByFK_Employee_Engineer = employeeRow.GetEngineerRows();
					//            for (int engineerIndex = 0; (engineerIndex < employeeEngineerRowsByFK_Employee_Engineer.Length); engineerIndex = (engineerIndex + 1)) {
					this.Statements.Add(new CodeVariableDeclarationStatement(rowArrayType, rowArrayVariableExpression.VariableName, new CodeMethodInvokeExpression(getMethodExpression)));
					CodeIterationStatement forEachRecord = new CodeIterationStatement(new CodeVariableDeclarationStatement(new CodeGlobalTypeReference(typeof(System.Int32)), iteratorVariableExpression.VariableName, new CodePrimitiveExpression(0)),
						new CodeBinaryOperatorExpression(iteratorVariableExpression, CodeBinaryOperatorType.LessThan, new CodePropertyReferenceExpression(rowArrayVariableExpression, "Length")),
						new CodeAssignStatement(iteratorVariableExpression, new CodeBinaryOperatorExpression(iteratorVariableExpression, CodeBinaryOperatorType.Add, new CodePrimitiveExpression(1))));

					//                // Get the next Engineer row in the list of children and lock it for the duration of the transaction.
					//                DataModel.EngineerRow engineerRow = employeeEngineerRowsByFK_Employee_Engineer[engineerIndex];
					//                engineerRow.AcquireWriterLock(middleTierTransaction.AdoResourceManager.Guid, FluidTrade.UnitTest.Server.DataModel.lockTimeout);
					//                middleTierTransaction.AdoResourceManager.AddLock(engineerRow);
					forEachRecord.Statements.Add(new CodeVariableDeclarationStatement(childRowType, childRowVariableExpression.VariableName, new CodeIndexerExpression(rowArrayVariableExpression, iteratorVariableExpression)));
					forEachRecord.Statements.Add(new CodeAcquireRecordWriterLockExpression(transactionExpression, childRowVariableExpression, tableSchema));
					forEachRecord.Statements.Add(new CodeAddLockToTransactionExpression(transactionExpression, childRowVariableExpression));

					//                // This makes sure the record wasn't deleted between the time it was found and the time it was locked.
					//                if ((engineerRow.RowState != System.Data.DataRowState.Detached)) {
					//                    this.DestroyEngineer(engineerRow.EngineerId, engineerRow.RowVersion);
					//                }
					CodeConditionStatement ifDetatched = new CodeConditionStatement(new CodeBinaryOperatorExpression(new CodePropertyReferenceExpression(childRowVariableExpression, "RowState"), CodeBinaryOperatorType.IdentityInequality, new CodePropertyReferenceExpression(new CodeGlobalTypeReferenceExpression(typeof(System.Data.DataRowState)), "Detached")));
					DestroyParameterMatrix childMatrix = new DestroyParameterMatrix(childTableSchema);
					List<CodeExpression> childParameters = new List<CodeExpression>();
					foreach (KeyValuePair<string, ExternalParameterItem> externalParameterPair in childMatrix.ExternalParameterItems)
						if (externalParameterPair.Value is UniqueConstraintParameterItem)
						{
							List<CodeExpression> primaryKeyParameters = new List<CodeExpression>();
							foreach (ColumnSchema primaryKeyColumn in childTableSchema.PrimaryKey.Columns)
								primaryKeyParameters.Add(new CodePropertyReferenceExpression(childRowVariableExpression, primaryKeyColumn.Name));
							childParameters.Add(new CodeArrayCreateExpression(new CodeGlobalTypeReference(typeof(System.Object)), primaryKeyParameters.ToArray()));
						}
						else
						{
							childParameters.Add(new CodePropertyReferenceExpression(childRowVariableExpression, "RowVersion"));
						}
					ifDetatched.TrueStatements.Add(new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), string.Format("Destroy{0}", childTableSchema.Name), childParameters.ToArray()));
					forEachRecord.Statements.Add(ifDetatched);

					//            }
					this.Statements.Add(forEachRecord);

				}

			//            System.Data.SqlClient.SqlCommand SqlCommand = new global::System.Data.SqlClient.SqlCommand("delete \"Employee\" where \"EmployeeId\"=@employeeId", middleTierTransaction.SqlConnection);
			//            SqlCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@employeeId", System.Data.SqlDbType.Int, 0, System.Data.ParameterDirection.Input, false, 0, 0, null, System.Data.DataRowVersion.Current, employeeRow[FluidTrade.UnitTest.Server.DataModel.Employee.EmployeeIdColumn]));
			//            SqlCommand.ExecuteNonQuery();
			if (tableSchema.IsPersistent)
			{
				CodeVariableReferenceExpression sqlCommandVariableExpression = new CodeRandomVariableReferenceExpression();
				if (tableSchema.PrimaryKey != null)
				{
					string deleteCommandText = string.Format("delete \"{0}\"", tableSchema.Name);
					ColumnSchema[] keyColumns = tableSchema.PrimaryKey.Columns;
					if (keyColumns.Length > 0)
					{
						deleteCommandText += string.Format(" where \"{0}\"=@{1}", keyColumns[0].Name, CommonConversion.ToCamelCase(keyColumns[0].Name));
						for (int keyIndex = 1; keyIndex < keyColumns.Length; keyIndex++)
							deleteCommandText += string.Format(" and \"{0}\"=@{1}", keyColumns[1].Name, CommonConversion.ToCamelCase(keyColumns[1].Name));
					}
					this.Statements.Add(new CodeVariableDeclarationStatement(new CodeGlobalTypeReference(typeof(System.Data.SqlClient.SqlCommand)), sqlCommandVariableExpression.VariableName, new CodeObjectCreateExpression(new CodeGlobalTypeReference(typeof(System.Data.SqlClient.SqlCommand)), new CodePrimitiveExpression(deleteCommandText), new CodePropertyReferenceExpression(transactionExpression, "SqlConnection"))));
					foreach (ColumnSchema columnSchema in tableSchema.PrimaryKey.Columns)
					{
						string variableName = CommonConversion.ToCamelCase(columnSchema.Name);
						CodeExpression codeExpression = new CodeIndexerExpression(rowVariableExpression, new CodePropertyReferenceExpression(new CodePropertyReferenceExpression(new CodeTypeReferenceExpression(tableSchema.DataModel.Name), tableSchema.Name), string.Format("{0}Column", columnSchema.Name)));
						this.Statements.Add(new CodeMethodInvokeExpression(new CodePropertyReferenceExpression(sqlCommandVariableExpression, "Parameters"), "Add", new CodeObjectCreateExpression(new CodeGlobalTypeReference(typeof(System.Data.SqlClient.SqlParameter)), new CodePrimitiveExpression(string.Format("@{0}", variableName)), TypeConverter.Convert(columnSchema.DataType), new CodePrimitiveExpression(0), new CodePropertyReferenceExpression(new CodeGlobalTypeReferenceExpression(typeof(System.Data.ParameterDirection)), "Input"), new CodePrimitiveExpression(false), new CodePrimitiveExpression(0), new CodePrimitiveExpression(0), new CodePrimitiveExpression(null), new CodePropertyReferenceExpression(new CodeGlobalTypeReferenceExpression(typeof(System.Data.DataRowVersion)), "Current"), codeExpression)));
					}
					this.Statements.Add(new CodeMethodInvokeExpression(sqlCommandVariableExpression, "ExecuteNonQuery"));
				}
			}

			//            // Delete the Employee record from the ADO data model.
			//            middleTierTransaction.AdoResourceManager.AddRecord(employeeRow);
			//            try {
			//                FluidTrade.UnitTest.Server.DataModel.ReaderWriterLock.EnterWriteLock();
			//                FluidTrade.UnitTest.Server.DataModel.ProjectMember.AcquireLock();
			//                employeeRow.Delete();
			//            }
			//            finally {
			//                FluidTrade.UnitTest.Server.DataModel.ReaderWriterLock.ExitWriteLock();
			//            }
			this.Statements.Add(new CodeAddRecordToTransactionExpression(transactionExpression, rowVariableExpression));
			CodeTryCatchFinallyStatement tryFinallyStatement = new CodeTryCatchFinallyStatement();
			tryFinallyStatement.TryStatements.Add(
				new CodeMethodInvokeExpression(
					new CodePropertyReferenceExpression(new CodeTypeReferenceExpression(tableSchema.DataModel.Name), "DataLock"), "EnterWriteLock"));
			tryFinallyStatement.TryStatements.Add(new CodeMethodInvokeExpression(rowVariableExpression, "Delete"));
			tryFinallyStatement.FinallyStatements.Add(
				new CodeMethodInvokeExpression(
					new CodePropertyReferenceExpression(new CodeTypeReferenceExpression(tableSchema.DataModel.Name), "DataLock"), "ExitWriteLock"));
			this.Statements.Add(tryFinallyStatement);

			//			DataModel.DestinationOrder.OnRowValidate(new DestinationOrderRowChangeEventArgs(pe9564f2717374e96a76d5222e2258784, System.Data.DataRowAction.Change));
			this.Statements.Add(new CodeMethodInvokeExpression(new CodePropertyReferenceExpression(new CodeTypeReferenceExpression(tableSchema.DataModel.Name), tableSchema.Name), "OnRowValidate",
				new CodeObjectCreateExpression(string.Format("{0}RowChangeEventArgs", tableSchema.Name), rowVariableExpression, new CodePropertyReferenceExpression(new CodeGlobalTypeReferenceExpression(typeof(System.Data.DataRowAction)), "Delete"))));

			//        }

		}

	}

}
